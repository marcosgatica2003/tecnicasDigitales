%how to find linear convolution using overlap add method 
%L=length of segment in which we will divide the input signal
%In 1st step L-r nos of zeros are added in x such that we will get L nos of
%data

%nr=no of rows
%Matrix M1 is generated by taking L samples from x1 for each row
% for M2 in each row M-1 zeros has been added
% h1 length has been made sama as the length of each row of M2 so that
%circular convolution of matrix M2 and h1 is possible and well get M3
%for column wise element addition M4 is generated
%El método de superposición-adición se basa en los siguiente: (1) descompone la señal en componentes simples,
%(2) procesa cada uno de los componentes de alguna manera útil, y (3) recombina los componentes procesados ??en la señal final.
clc
clear all
close all
x=[1 2 3 4 5 6 7 8 9 3 5 6 7];
h=[2 2 1];
% x=input('enter x');
% h=input('enter h');
% L=input('enter L')
M=length(h) %longitud de respuesta al impulso
lx=length(x) %longitud del vector con todas las muestras
L=5; %muestras procesadas por bloque
r=rem(lx,L); %saca el resto entre la longitud de todas las muestras y la seccion L de ellas que voy a tomar en cada bloque
x1=[x zeros(1,L-r)]; %completa con ceros al vector de muestras para que entren todos los bloques
lx1=length(x1); %longitud de la señal
nr=length(x1)/L; %cantidad de bloques a procesar
h1=[h zeros(1,L-1)];  %completo con ceros el vector de respuesta al impulso (agrego L-1)
for k=1:nr
    M1(k,:)=x1(((k-1)*L+1):k*L); %Ma es un vector cuyas filas es el numero total de bloques a procesar y columnas contienen la porcion de datos a procesar
                                % (k-1)*L+1 me posiciona en el primer
                                % elemento del bloque que quiero copiar en
                                % Ma y va hasta k*L que me da el ultimo
                                % elemento
    M2(k,:)=[M1(k,:) zeros(1,M-1)]; %agrego al final de cada bloque M-1 ceros para permitir la expansion durante la convolucion
    M3(k,:)=ifft(fft(M2(k,:)).*fft(h1)); %hago la transformada punto a punto inversa de la transformada de la matriz anterior (obtengo y1[n])
    M4(k,:)=[zeros(1,(k-1)*L) M3(k,:) zeros(1,(nr-k)*L)];
end
y=sum(M4)